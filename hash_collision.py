import hashlib
import os


# a brute-force algorithm to find a partial collision
def hash_collision(k):
    if not isinstance(k, int):
        print("hash_collision expects an integer")
        return (b'\x00', b'\x00')
    if k < 0:
        print("Specify a positive number of bits")
        return (b'\x00', b'\x00')

    # Collision finding code goes here

    x = os.urandom(32)  # generate random bytes of 32
    x_hash = hashlib.sha256()  # initialize hash object
    x_hash.update(x)  # update hash object with randomly generated bytes
    hex_hash = x_hash.hexdigest()  # get hex hash code
    bin_hash = bin(int(hex_hash, 16))  # convert hex hash code into binary hash code

    partial_bin_hash = bin_hash[-k:len(bin_hash)]  # slide the final k pieces of binary hash code

    # loop to search for the random byte code with the partial hash value
    while 1:
        y = os.urandom(32)  # generate random bytes of 32
        y_hash = hashlib.sha256()  # initialize hash object
        y_hash.update(y)  # update hash object with randomly generated bytes
        y_hex_hash = y_hash.hexdigest()  # get hex hash code
        y_bin_hash = bin(int(y_hex_hash, 16))  # convert hex hash code into binary hash code

        partial_y_bin_hash = y_bin_hash[-k:len(y_bin_hash)]  # slide the final k pieces of binary hash code

        # break in case of partial hash values are matched
        if partial_y_bin_hash == partial_bin_hash:
            break

    # return two byte codes
    return x, y

